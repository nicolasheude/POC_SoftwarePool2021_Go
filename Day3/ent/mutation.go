// Code generated by entc, DO NOT EDIT.

package ent

import (
	"SofwareGoDay3/ent/competence"
	"SofwareGoDay3/ent/contact"
	"SofwareGoDay3/ent/developper"
	"SofwareGoDay3/ent/predicate"
	"context"
	"fmt"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCompetence = "Competence"
	TypeContact    = "Contact"
	TypeDevelopper = "Developper"
)

// CompetenceMutation represents an operation that mutates the Competence nodes in the graph.
type CompetenceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	level         *int
	addlevel      *int
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Competence, error)
	predicates    []predicate.Competence
}

var _ ent.Mutation = (*CompetenceMutation)(nil)

// competenceOption allows management of the mutation configuration using functional options.
type competenceOption func(*CompetenceMutation)

// newCompetenceMutation creates new mutation for the Competence entity.
func newCompetenceMutation(c config, op Op, opts ...competenceOption) *CompetenceMutation {
	m := &CompetenceMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetenceID sets the ID field of the mutation.
func withCompetenceID(id int) competenceOption {
	return func(m *CompetenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Competence
		)
		m.oldValue = func(ctx context.Context) (*Competence, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetence sets the old Competence of the mutation.
func withCompetence(node *Competence) competenceOption {
	return func(m *CompetenceMutation) {
		m.oldValue = func(context.Context) (*Competence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competence entities.
func (m *CompetenceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CompetenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *CompetenceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompetenceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Competence entity.
// If the Competence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetenceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompetenceMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *CompetenceMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CompetenceMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Competence entity.
// If the Competence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetenceMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CompetenceMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CompetenceMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CompetenceMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetOwnerID sets the "owner" edge to the Developper entity by id.
func (m *CompetenceMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Developper entity.
func (m *CompetenceMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the "owner" edge to the Developper entity was cleared.
func (m *CompetenceMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CompetenceMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CompetenceMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CompetenceMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *CompetenceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Competence).
func (m *CompetenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetenceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, competence.FieldName)
	}
	if m.level != nil {
		fields = append(fields, competence.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competence.FieldName:
		return m.Name()
	case competence.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competence.FieldName:
		return m.OldName(ctx)
	case competence.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Competence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competence.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case competence.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Competence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetenceMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, competence.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case competence.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case competence.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Competence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Competence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetenceMutation) ResetField(name string) error {
	switch name {
	case competence.FieldName:
		m.ResetName()
		return nil
	case competence.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Competence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, competence.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competence.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetenceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, competence.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetenceMutation) EdgeCleared(name string) bool {
	switch name {
	case competence.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetenceMutation) ClearEdge(name string) error {
	switch name {
	case competence.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Competence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetenceMutation) ResetEdge(name string) error {
	switch name {
	case competence.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Competence edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	phone         *string
	github        *string
	linkedin      *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Contact, error)
	predicates    []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id int) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contact entities.
func (m *ContactMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ContactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *ContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *ContactMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ContactMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ContactMutation) ResetPhone() {
	m.phone = nil
}

// SetGithub sets the "github" field.
func (m *ContactMutation) SetGithub(s string) {
	m.github = &s
}

// Github returns the value of the "github" field in the mutation.
func (m *ContactMutation) Github() (r string, exists bool) {
	v := m.github
	if v == nil {
		return
	}
	return *v, true
}

// OldGithub returns the old "github" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldGithub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithub: %w", err)
	}
	return oldValue.Github, nil
}

// ResetGithub resets all changes to the "github" field.
func (m *ContactMutation) ResetGithub() {
	m.github = nil
}

// SetLinkedin sets the "linkedin" field.
func (m *ContactMutation) SetLinkedin(s string) {
	m.linkedin = &s
}

// Linkedin returns the value of the "linkedin" field in the mutation.
func (m *ContactMutation) Linkedin() (r string, exists bool) {
	v := m.linkedin
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedin returns the old "linkedin" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldLinkedin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLinkedin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLinkedin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedin: %w", err)
	}
	return oldValue.Linkedin, nil
}

// ResetLinkedin resets all changes to the "linkedin" field.
func (m *ContactMutation) ResetLinkedin() {
	m.linkedin = nil
}

// SetOwnerID sets the "owner" edge to the Developper entity by id.
func (m *ContactMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Developper entity.
func (m *ContactMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the "owner" edge to the Developper entity was cleared.
func (m *ContactMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ContactMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ContactMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, contact.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, contact.FieldPhone)
	}
	if m.github != nil {
		fields = append(fields, contact.FieldGithub)
	}
	if m.linkedin != nil {
		fields = append(fields, contact.FieldLinkedin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldEmail:
		return m.Email()
	case contact.FieldPhone:
		return m.Phone()
	case contact.FieldGithub:
		return m.Github()
	case contact.FieldLinkedin:
		return m.Linkedin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldEmail:
		return m.OldEmail(ctx)
	case contact.FieldPhone:
		return m.OldPhone(ctx)
	case contact.FieldGithub:
		return m.OldGithub(ctx)
	case contact.FieldLinkedin:
		return m.OldLinkedin(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contact.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case contact.FieldGithub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithub(v)
		return nil
	case contact.FieldLinkedin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedin(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldEmail:
		m.ResetEmail()
		return nil
	case contact.FieldPhone:
		m.ResetPhone()
		return nil
	case contact.FieldGithub:
		m.ResetGithub()
		return nil
	case contact.FieldLinkedin:
		m.ResetLinkedin()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, contact.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, contact.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	switch name {
	case contact.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Contact edge %s", name)
}

// DevelopperMutation represents an operation that mutates the Developper nodes in the graph.
type DevelopperMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	age               *int
	addage            *int
	school            *string
	experience        *int
	addexperience     *int
	clearedFields     map[string]struct{}
	contact           *int
	clearedcontact    bool
	competence        map[int]struct{}
	removedcompetence map[int]struct{}
	clearedcompetence bool
	done              bool
	oldValue          func(context.Context) (*Developper, error)
	predicates        []predicate.Developper
}

var _ ent.Mutation = (*DevelopperMutation)(nil)

// developperOption allows management of the mutation configuration using functional options.
type developperOption func(*DevelopperMutation)

// newDevelopperMutation creates new mutation for the Developper entity.
func newDevelopperMutation(c config, op Op, opts ...developperOption) *DevelopperMutation {
	m := &DevelopperMutation{
		config:        c,
		op:            op,
		typ:           TypeDevelopper,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDevelopperID sets the ID field of the mutation.
func withDevelopperID(id int) developperOption {
	return func(m *DevelopperMutation) {
		var (
			err   error
			once  sync.Once
			value *Developper
		)
		m.oldValue = func(ctx context.Context) (*Developper, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Developper.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevelopper sets the old Developper of the mutation.
func withDevelopper(node *Developper) developperOption {
	return func(m *DevelopperMutation) {
		m.oldValue = func(context.Context) (*Developper, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DevelopperMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DevelopperMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Developper entities.
func (m *DevelopperMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DevelopperMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *DevelopperMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DevelopperMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Developper entity.
// If the Developper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevelopperMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DevelopperMutation) ResetName() {
	m.name = nil
}

// SetAge sets the "age" field.
func (m *DevelopperMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *DevelopperMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Developper entity.
// If the Developper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevelopperMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *DevelopperMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *DevelopperMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *DevelopperMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetSchool sets the "school" field.
func (m *DevelopperMutation) SetSchool(s string) {
	m.school = &s
}

// School returns the value of the "school" field in the mutation.
func (m *DevelopperMutation) School() (r string, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSchool returns the old "school" field's value of the Developper entity.
// If the Developper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevelopperMutation) OldSchool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchool: %w", err)
	}
	return oldValue.School, nil
}

// ResetSchool resets all changes to the "school" field.
func (m *DevelopperMutation) ResetSchool() {
	m.school = nil
}

// SetExperience sets the "experience" field.
func (m *DevelopperMutation) SetExperience(i int) {
	m.experience = &i
	m.addexperience = nil
}

// Experience returns the value of the "experience" field in the mutation.
func (m *DevelopperMutation) Experience() (r int, exists bool) {
	v := m.experience
	if v == nil {
		return
	}
	return *v, true
}

// OldExperience returns the old "experience" field's value of the Developper entity.
// If the Developper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevelopperMutation) OldExperience(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperience: %w", err)
	}
	return oldValue.Experience, nil
}

// AddExperience adds i to the "experience" field.
func (m *DevelopperMutation) AddExperience(i int) {
	if m.addexperience != nil {
		*m.addexperience += i
	} else {
		m.addexperience = &i
	}
}

// AddedExperience returns the value that was added to the "experience" field in this mutation.
func (m *DevelopperMutation) AddedExperience() (r int, exists bool) {
	v := m.addexperience
	if v == nil {
		return
	}
	return *v, true
}

// ResetExperience resets all changes to the "experience" field.
func (m *DevelopperMutation) ResetExperience() {
	m.experience = nil
	m.addexperience = nil
}

// SetContactID sets the "contact" edge to the Contact entity by id.
func (m *DevelopperMutation) SetContactID(id int) {
	m.contact = &id
}

// ClearContact clears the "contact" edge to the Contact entity.
func (m *DevelopperMutation) ClearContact() {
	m.clearedcontact = true
}

// ContactCleared returns if the "contact" edge to the Contact entity was cleared.
func (m *DevelopperMutation) ContactCleared() bool {
	return m.clearedcontact
}

// ContactID returns the "contact" edge ID in the mutation.
func (m *DevelopperMutation) ContactID() (id int, exists bool) {
	if m.contact != nil {
		return *m.contact, true
	}
	return
}

// ContactIDs returns the "contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContactID instead. It exists only for internal usage by the builders.
func (m *DevelopperMutation) ContactIDs() (ids []int) {
	if id := m.contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContact resets all changes to the "contact" edge.
func (m *DevelopperMutation) ResetContact() {
	m.contact = nil
	m.clearedcontact = false
}

// AddCompetenceIDs adds the "competence" edge to the Competence entity by ids.
func (m *DevelopperMutation) AddCompetenceIDs(ids ...int) {
	if m.competence == nil {
		m.competence = make(map[int]struct{})
	}
	for i := range ids {
		m.competence[ids[i]] = struct{}{}
	}
}

// ClearCompetence clears the "competence" edge to the Competence entity.
func (m *DevelopperMutation) ClearCompetence() {
	m.clearedcompetence = true
}

// CompetenceCleared returns if the "competence" edge to the Competence entity was cleared.
func (m *DevelopperMutation) CompetenceCleared() bool {
	return m.clearedcompetence
}

// RemoveCompetenceIDs removes the "competence" edge to the Competence entity by IDs.
func (m *DevelopperMutation) RemoveCompetenceIDs(ids ...int) {
	if m.removedcompetence == nil {
		m.removedcompetence = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcompetence[ids[i]] = struct{}{}
	}
}

// RemovedCompetence returns the removed IDs of the "competence" edge to the Competence entity.
func (m *DevelopperMutation) RemovedCompetenceIDs() (ids []int) {
	for id := range m.removedcompetence {
		ids = append(ids, id)
	}
	return
}

// CompetenceIDs returns the "competence" edge IDs in the mutation.
func (m *DevelopperMutation) CompetenceIDs() (ids []int) {
	for id := range m.competence {
		ids = append(ids, id)
	}
	return
}

// ResetCompetence resets all changes to the "competence" edge.
func (m *DevelopperMutation) ResetCompetence() {
	m.competence = nil
	m.clearedcompetence = false
	m.removedcompetence = nil
}

// Op returns the operation name.
func (m *DevelopperMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Developper).
func (m *DevelopperMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DevelopperMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, developper.FieldName)
	}
	if m.age != nil {
		fields = append(fields, developper.FieldAge)
	}
	if m.school != nil {
		fields = append(fields, developper.FieldSchool)
	}
	if m.experience != nil {
		fields = append(fields, developper.FieldExperience)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DevelopperMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case developper.FieldName:
		return m.Name()
	case developper.FieldAge:
		return m.Age()
	case developper.FieldSchool:
		return m.School()
	case developper.FieldExperience:
		return m.Experience()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DevelopperMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case developper.FieldName:
		return m.OldName(ctx)
	case developper.FieldAge:
		return m.OldAge(ctx)
	case developper.FieldSchool:
		return m.OldSchool(ctx)
	case developper.FieldExperience:
		return m.OldExperience(ctx)
	}
	return nil, fmt.Errorf("unknown Developper field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevelopperMutation) SetField(name string, value ent.Value) error {
	switch name {
	case developper.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case developper.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case developper.FieldSchool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchool(v)
		return nil
	case developper.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperience(v)
		return nil
	}
	return fmt.Errorf("unknown Developper field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DevelopperMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, developper.FieldAge)
	}
	if m.addexperience != nil {
		fields = append(fields, developper.FieldExperience)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DevelopperMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case developper.FieldAge:
		return m.AddedAge()
	case developper.FieldExperience:
		return m.AddedExperience()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevelopperMutation) AddField(name string, value ent.Value) error {
	switch name {
	case developper.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case developper.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExperience(v)
		return nil
	}
	return fmt.Errorf("unknown Developper numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DevelopperMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DevelopperMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DevelopperMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Developper nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DevelopperMutation) ResetField(name string) error {
	switch name {
	case developper.FieldName:
		m.ResetName()
		return nil
	case developper.FieldAge:
		m.ResetAge()
		return nil
	case developper.FieldSchool:
		m.ResetSchool()
		return nil
	case developper.FieldExperience:
		m.ResetExperience()
		return nil
	}
	return fmt.Errorf("unknown Developper field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DevelopperMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.contact != nil {
		edges = append(edges, developper.EdgeContact)
	}
	if m.competence != nil {
		edges = append(edges, developper.EdgeCompetence)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DevelopperMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case developper.EdgeContact:
		if id := m.contact; id != nil {
			return []ent.Value{*id}
		}
	case developper.EdgeCompetence:
		ids := make([]ent.Value, 0, len(m.competence))
		for id := range m.competence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DevelopperMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcompetence != nil {
		edges = append(edges, developper.EdgeCompetence)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DevelopperMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case developper.EdgeCompetence:
		ids := make([]ent.Value, 0, len(m.removedcompetence))
		for id := range m.removedcompetence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DevelopperMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontact {
		edges = append(edges, developper.EdgeContact)
	}
	if m.clearedcompetence {
		edges = append(edges, developper.EdgeCompetence)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DevelopperMutation) EdgeCleared(name string) bool {
	switch name {
	case developper.EdgeContact:
		return m.clearedcontact
	case developper.EdgeCompetence:
		return m.clearedcompetence
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DevelopperMutation) ClearEdge(name string) error {
	switch name {
	case developper.EdgeContact:
		m.ClearContact()
		return nil
	}
	return fmt.Errorf("unknown Developper unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DevelopperMutation) ResetEdge(name string) error {
	switch name {
	case developper.EdgeContact:
		m.ResetContact()
		return nil
	case developper.EdgeCompetence:
		m.ResetCompetence()
		return nil
	}
	return fmt.Errorf("unknown Developper edge %s", name)
}
